@document.meta
title: Phase 1 Dogfooding MVP - Implementation Timeline
description: Detailed 6-week implementation plan for dogfooding-capable MVP
authors: genie
categories: [project-management, timeline, implementation]
created: 2024-06-16
updated: 2024-06-16
version: 1.0.0
@end

* Phase 1 Architecture Foundation - Implementation Timeline
  /4-week focused implementation plan/

** Overview

*Goal*: Build the core API layers and tool system foundation for Genie
*Timeline*: 4 weeks (28 days)  
*Team Size*: 1-2 developers
*Success Metric*: Working context layer + tool orchestration + basic tools for development assistance

** Current State (âœ… Completed)

*** Foundation Infrastructure
     - [x] Go project structure with standard layout
     - [x] Cobra CLI framework with logging flags  
     - [x] Configuration system (pkg/config)
     - [x] Structured logging with slog (pkg/logging)
     - [x] Google Wire dependency injection (internal/di)
     - [x] LLM abstraction (ai.Gen interface)
     - [x] Vertex AI client implementation
     - [x] Basic ask command with DI
     - [x] File operations (pkg/fileops)
     - [x] Template engine (pkg/template)

** Week-by-Week Plan

*** Week 1: Core API & Session Layer (Days 1-7)

**** Session Management (Days 1-3)
     - [ ] Create pkg/session package
     - [ ] Session interface and basic implementation
     - [ ] Context management (conversation history)
     - [ ] Memory integration (CLAUDE.md file handling)
     - [ ] Basic cost tracking structure

**** Core API Foundation (Days 4-5)
     - [ ] Create pkg/api package
     - [ ] GenieAPI interface definition
     - [ ] Basic implementation with session integration
     - [ ] Wire integration for API layer

**** Context Integration (Days 6-7)
     - [ ] Update ask command to use session context
     - [ ] Add session persistence
     - [ ] Basic conversation memory

**** Week 1 Deliverable
     Working session management with persistent context

*** Week 2: Tool System Foundation (Days 8-14)

**** Tool Interface Design (Days 8-10)
     - [ ] Create pkg/tools package with common Tool interface
     - [ ] Migrate existing fileops to implement Tool interface
     - [ ] Create tool registration and discovery system
     - [ ] Add parameter validation and schema support

**** Basic Tool Categories (Days 11-12)
     - [ ] Implement pkg/tools/fileops with Read, Write, Edit, MultiEdit, Glob, LS
     - [ ] Create pkg/tools/search with Grep and Find tools
     - [ ] Design permission system for tool execution

**** Tool Orchestrator (Days 13-14)
     - [ ] Create pkg/orchestrator package
     - [ ] Implement tool registry and execution coordination
     - [ ] Add basic permission checking
     - [ ] Wire integration for tool dependencies

**** Week 2 Deliverable
     Working tool system with basic file and search operations

*** Week 3: LLM Integration & Function Calling (Days 15-21)

**** LLM Manager Design (Days 15-17)
     - [ ] Create pkg/llm package with Manager interface
     - [ ] Refactor existing Vertex client to implement Provider interface
     - [ ] Add model selection and configuration management
     - [ ] Implement function calling coordination

**** Tool Function Integration (Days 18-19)
     - [ ] Generate function declarations from tool interfaces
     - [ ] Implement function call routing to tools
     - [ ] Add result formatting and error handling
     - [ ] Test LLM-tool interaction workflows

**** Enhanced Ask Command (Days 20-21)
     - [ ] Update ask command to use session context and tools
     - [ ] Add streaming response support
     - [ ] Implement multi-turn conversations with tool usage
     - [ ] Add cost tracking and token management

**** Week 3 Deliverable
     Working LLM integration with tool calling capabilities

*** Week 4: Development Tools & CLI Enhancement (Days 22-28)

**** Development Tool Implementation (Days 22-24)
     - [ ] Create pkg/tools/build with Go, Make, Docker tools
     - [ ] Create pkg/tools/test with Go test, coverage tools
     - [ ] Create pkg/tools/git with status, commit, diff tools
     - [ ] Add shell command execution tool with security controls

**** CLI Command Enhancement (Days 25-26)
     - [ ] Add config command for settings management
     - [ ] Add session command for context management
     - [ ] Add tool command for listing and executing tools
     - [ ] Add doctor command for health diagnostics

**** Polish & Integration (Days 27-28)
     - [ ] Update all commands to use Core API layer
     - [ ] Add comprehensive error handling and user feedback
     - [ ] Implement basic cost tracking display
     - [ ] Add configuration validation and defaults

**** Week 4 Deliverable
     Complete CLI with Core API integration and development tools

** Additional Components (If Time Permits)

*** MCP Integration Foundation
     - [ ] Create pkg/mcp package structure
     - [ ] Implement basic MCP server to expose tools
     - [ ] Add .mcp.json configuration parsing
     - [ ] Test with external MCP clients

*** Advanced Features
     - [ ] Context compression and optimization
     - [ ] Multi-session support
     - [ ] Advanced search with semantic understanding
     - [ ] Performance monitoring and optimization

** Daily Milestones

*** Critical Path Items
    - Day 7: Session management and Core API foundation working
    - Day 14: Tool system operational with basic file operations
    - Day 21: LLM integration with function calling to tools
    - Day 28: Complete CLI commands using Core API architecture

*** Risk Mitigation
    - Day 7: If session complexity high, start with in-memory implementation
    - Day 14: If tool interface design complex, focus on core file operations first
    - Day 21: If function calling integration difficult, implement basic tool execution
    - Day 28: If CLI refactoring extensive, prioritize ask and config commands

** Success Validation

*** Functional Tests
    - [ ] Session management preserves context across interactions
    - [ ] Tool system executes file operations safely
    - [ ] LLM can call tools through function calling interface
    - [ ] Ask command provides intelligent code assistance
    - [ ] Config command manages settings effectively
    - [ ] Tool orchestrator handles permissions and execution

*** Architecture Validation Tests
    - [ ] Core API can be used independently of CLI
    - [ ] Tool system is extensible for new tool categories
    - [ ] Session management scales to complex conversations
    - [ ] LLM integration supports multiple providers
    - [ ] Configuration system handles all required settings

*** Integration Tests
    - [ ] All components work together seamlessly
    - [ ] Wire dependency injection resolves correctly
    - [ ] Error handling is consistent across layers
    - [ ] Logging provides appropriate visibility

** Resource Requirements

*** Development Environment
    - Go 1.21+ development environment
    - Git repository access
    - Gemini API access and credits
    - Testing infrastructure

*** External Dependencies
    - Cobra CLI framework
    - Google Wire for dependency injection
    - Vertex AI Go SDK
    - Standard Go testing tools
    - slog for structured logging

** Risk Assessment

*** High Risk
    - Tool orchestration complexity affecting development timeline
    - Session management persistence complexity
    - LLM function calling integration challenges

*** Medium Risk
    - Wire dependency injection learning curve
    - Multi-provider LLM abstraction complexity
    - Configuration management across layers

*** Low Risk
    - Cobra CLI framework usage
    - Basic logging and error handling
    - Core API interface design

** Post-Phase 1 Benefits

*** Architectural Foundation
    - Clean separation of concerns enables easy extension
    - Tool system allows rapid addition of new capabilities
    - Session management provides foundation for advanced features
    - LLM abstraction supports multiple providers and models

*** Development Velocity
    - Well-defined interfaces speed up feature development
    - Wire dependency injection makes testing easier
    - Core API enables multiple front-ends (CLI, web, IDE)
    - Tool orchestration simplifies complex workflow implementation

*** Quality & Maintainability
    - Testable architecture with clear component boundaries
    - Consistent error handling and logging across all layers
    - Configuration management supports all deployment scenarios
    - Session persistence enables sophisticated user experiences

** Conclusion

This Phase 1 establishes a robust architectural foundation that aligns with our target architecture and enables rapid development of advanced AI-powered development assistance features. The focus on core API layers, tool orchestration, and session management creates the infrastructure needed for Phase 2's more sophisticated capabilities while providing immediate value through intelligent code assistance.